\documentclass[a4paper,11pt]{article}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[a4paper,total={150mm,240mm}]{geometry}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{amscd}

\usepackage[envcountsect,noamsthm]{beamerarticle}

\usepackage{grffile}
\usepackage{tikz}
\usetikzlibrary{3d,calc}
\usepackage{eurosym}
\usepackage{graphicx}
\usepackage{color}
\definecolor{listingbg}{gray}{0.95}
\usepackage{listings}
\lstset{language=C++, basicstyle=\ttfamily,
  keywordstyle=\color{black}\bfseries, tabsize=4, stringstyle=\ttfamily,
  commentstyle=\itshape, extendedchars=false,backgroundcolor=\color{listingbg},escapeinside={/*@}{@*/}}
\usepackage{paralist}
\usepackage{curves}
\usepackage{calc}
\usepackage{picinpar}
\usepackage{enumerate}
\usepackage{algpseudocode}
\usepackage{bm}
\usepackage{multibib}
\usepackage{hyperref}
\usepackage{textcase}
\usepackage{nicefrac}
\usepackage[titletoc,toc,title]{appendix}

\theoremstyle{definition}
\newtheorem{exm}{Example}
\newtheorem{thm}{Theorem}
\newtheorem{cor}{Corollary}
\newtheorem{obs}{Observation}

\title{HDNUM\\ CPP Review Proyecto para Latinoamérica}
\author{Peter Bastian\\
  Universität Heidelberg, \\
  Traducido por John Jairo Leal G,\\
  Universidad Nacional de Colombia, \\
  Línea de investigación en Modelamiento Matemático\\
}
\date{\today}

\begin{document}

\maketitle



\begin{abstract}
Este manual de Hdnum, está basado en la propuesta presentada por la universidad de 
Heidelberg Alemania en el curso de Lima, Perú en 2020, para introducirse en el manejo de las soluciones de ecuaciones
diferenciales ordinarias y parciales.
\end{abstract}

\tableofcontents{tocdepth}{5}

\section{Introducción}
Haremos un breve resumen de HDNUM
\subsection{Que es HDNUM?}
La biblioteca numérica de Heildeberg HDNUM, es una biblioteca basada en C++ para realizar ejercicios prácticos en clases
magistrales, que incluye métodos numéricos para resolver ecuaciones diferenciales ordinarias, la actual versión está 
disponible en :
\begin{center}
\url{https://parcomp-git.iwr.uni-heidelberg.de/Teaching/hdnum}
\end{center}

Que tiene un control de vesiones administrada por \lstinline{git} .
Spezifische Versionen können auf der jeweiligen Vorlesungswebseite veröffentlicht werden.

Los objetivos en el desarrollo de HDNUM fueron i) la facilidad de uso (incluida la instalación simple), ii) la demostración de la programación orientada a objetos en la solución de métodos numéricos, así como la posibilidad de realizar cálculos con cualquier grado de precisión sobre la base de Gnu Multiple Precision Biblioteca. HDNUM ofrece actualmente las siguientes funciones:
\begin{enumerate}[1)]
\item Clases para vectores y matrices
\item Solución de sistemas de ecuaciones lineales
\item Solución de sistemas de ecuaciones no lineales
\item Solución de la ecuación de Poisson utilizando diferencias finitas
\end{enumerate}

\subsection{Instalación de HDNUM 2}

HDNUM es una biblioteca de ''solo encabezado'' y no requiere ninguna instalación más que descargar los archivos. La versión actual se puede encontrar usando el siguiente comando para descargarla:

\begin{lstlisting}[basicstyle=\ttfamily\footnotesize,language=bash,frame=single]
$ git clone https://parcomp-git.iwr.uni-heidelberg.de/Teaching/hdnum.git
\end{lstlisting}

Para realizar esto se requiere el programa \lstinline{git}, el cual está disponible gratuitamente para todos los sistemas operativos. Alternativamente también hay un archivo comprimido que se puede descargar \lstinline{tar} en la página del evento.
\begin{lstlisting}[basicstyle=\ttfamily\small,frame=single]
$ tar zxvf hdnum-XX.tgz
\end{lstlisting}
Los siguientes archivos y subdirectorios se pueden encontrar en el directorio instalado o descomprimido:
\begin{itemize}
\item \lstinline{hdnum.hh}: Este archivo encabezado debe estar integrado en los programa \lstinline{C++} para poder utilizar HDNUM.
\item 
El directorio \lstinline{mystuff} está destinado a sus programas, pero, por supuesto, puede utilizar cualquier otro directorio. Lo único importante es que el compilador tenga el archivo \lstinline{hdnum.hh} que encontró. En el registro mystuff ya es un programa de muestra para comenzar de inmediato. Este programa se puede compilar de la siguiente forma:

\begin{lstlisting}[basicstyle=\ttfamily\small,frame=single]
$ cd mystuff
$ g++ -I.. -o example example.cc
\end{lstlisting}
Otra forma es utilizar el comando \lstinline{make}, el cual ejecutará el archivo \lstinline{Makefile} que está en la carpeta, y el cual compilará el programa ejemplo, generando el archivo ejecutable \lstinline{example} que lo puede correr con \lstinline{./example}.

Estos comandos requieren que el compilador GNU C ++ esté instalado en su sistema. En Windows o para otros compiladores, debe adaptar los comandos en consecuencia.

\item El directorio \lstinline{examples} en la carpeta HDNUM contiene muchos ejemplos ordenados para el curso de programación, \lstinline{num0} y \lstinline{num1}.
\item El directorio \lstinline{src} en la carpeta HDNUM contiene el código fuente de la biblioteca HDNUM. Estos archivos son utilizados por hdnum.hh cuando sea invocado.
\item El directorio \lstinline{programmierkurs} en la carpeta HDNUM contiene el código fuente de este documento
\item El directorio \lstinline{tutorial}  en la carpeta HDNUM contiene las diapositivas del curso de programación.
\end{itemize}

\subsubsection*{GNU Biblioteca de Multiple Precisión}

HDNUM puede realizar cálculos con gran precisión. Esto requiere la biblioteca GNU Multiple Precision Library (GMP), que puede obtener de forma gratuita para muchos sistemas. Para poder utilizar GMP debe poner en el archivo \lstinline{hdnum.hh} la línea:
\begin{lstlisting}[basicstyle=\ttfamily\small,frame=single]
#define HDNUM_HAS_GMP 1
\end{lstlisting}
Además, las opciones del compilador pueden ser necesarias para que el compilador pueda encontrar las bibliotecas y los archivos de encabezado GMP. Entonces puede verse así:
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize,frame=single]
$ g++ -I.. -I/opt/local/include -o example example.cc -L/opt/local/lib -lgmpxx -lgmp
\end{lstlisting}
% $

\section{Algebra Lineal}

\subsection{Vectores}

\begin{frame}[fragile]
\frametitle{\lstinline{hdnum::Vector<T>}}
\begin{itemize}
\item \lstinline{hdnum::Vector<T>} es una plantilla de Clase.
\item Convierte cualquier (número)  tipo de datos \lstinline{T} en un vector. 
\item También son posibles números complejos y muy precisos.
\item Los vectores se comportan como los conocemos por las matemáticas:
\begin{itemize}
\item Tiene $n$ componentes.
\item Inicia en el elemento $0$ hasta el elemento $n-1$ numerados consecutivamente.
\item Adición y multiplicación por un escalar.
\item Producto escalar y norma Euclidiana.
\item Multiplicación vector-matriz.
\end{itemize}
\item Los siguientes ejemplos se pueden encontrar en el archivo \lstinline{vektoren.cc}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Construcción y Acceso}
\begin{itemize}
\item Construcción con y sin Inicialización\\
{\footnotesize{\begin{lstlisting}{}
hdnum::Vector<float> x(10);        // Vector con 10 elementos
hdnum::Vector<double> y(10,3.14);  // Vector con 10 elementos inicializado
hdnum::Vector<float> a;            // Vector sin elementos
\end{lstlisting}}}
\item Vectores más específicos\\
{\footnotesize{\begin{lstlisting}{}
hdnum::Vector<std::complex<double> >
  cx(7,std::complex<double>(1.0,3.0));
mpf_set_default_prec(1024); // Establece precision para  mpf_class
hdnum::Vector<mpf_class> mx(7,mpf_class("4.44"));
\end{lstlisting}}}
\item Acceso a un elemento\\
{\footnotesize{\begin{lstlisting}{}
for (std::size_t i=0; i<x.size(); i=i+1)
  x[i] = i;                 // Acceso a cada elemento
\end{lstlisting}}}
\item El objeto vectorial se elimina al final del ciclo for.
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Copia y Asignación}
\begin{itemize}
\item Constructor copia: crea una copia de otro vector
{\footnotesize{\begin{lstlisting}{}
hdnum::Vector<float> z(x); // z es copia de x
\end{lstlisting}}}
\item Asignación, ¡El tamaño también cambia!
{\footnotesize{\begin{lstlisting}{}
b = z;              // b copia los datos de z 
a = 5.4;            // asignacion a todos los elementos
hdnum::Vector<double> w;   // Vector sin elementos
w.resize(x.size()); // Redimiensiona el vector 
w = x;              // Copia los elementos
\end{lstlisting}}}
\item Extracto de vectores\\
{\footnotesize{\begin{lstlisting}{}
hdnum::Vector<float> w(x.sub(7,3));// w es una copia de x[7],...,x[9]
z = x.sub(3,4);             // z es una copia de x[3],...,x[6]
\end{lstlisting}}}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Cálculos y operaciones}
\begin{itemize}
\item Operaciones de espacio vectorial y producto escalar \\
{\footnotesize{\begin{lstlisting}{}
w += z;            // w = w+z
w -= z;            // w = w-z
w *= 1.23;         // Multiplicacion por escalar
w /= 1.23;         // Division por escalar
w.update(1.23,z);  // w = w + a*z
float s;
s = w*z;           // Producto escalar
\end{lstlisting}}}
\item Mostrando las salidas\\
{\footnotesize{\begin{lstlisting}{}
std::cout << w << std::endl;// Salida por pantalla
w.iwidth(2);                // Digitos en la salida del indice
w.width(20);                // Definiendo la cantidad de digitos
w.precision(16);            // Numero de posiciones decimales
std::cout << w << std::endl;// Imprimiendo w
std::cout <<cx << std::endl;// Imprimiendo complejos
std::cout <<mx << std::endl;// Funciona para mpf_class
\end{lstlisting}}}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Visualización}
{\footnotesize{\begin{lstlisting}{}
[   0]    1.204200e+01
[   1]    1.204200e+01
[   2]    1.204200e+01
[   3]    1.204200e+01

[ 0] 1.2042000770568848e+01
[ 1] 1.2042000770568848e+01
[ 2] 1.2042000770568848e+01
[ 3] 1.2042000770568848e+01
\end{lstlisting}}}
\end{frame}

\begin{frame}[fragile]
\frametitle{Funciones auxiliares}
{\footnotesize{\begin{lstlisting}{}
float d = norm(w);          // Norma Euclidea
d = w.two_norm();           // La misma norma
zero(w);                    // Igual que w=0.0
fill(w,(float)1.0);         // Igual que w=1.0
fill(w,(float)0.0,(float)0.1); // w[0]=0, w[1]=0.1, w[2]=0.2, ...
unitvector(w,2);            // Vector unitario cartesiano
gnuplot("test.dat",w);      // Salida a gnuplo: i w[i]
gnuplot("test2.dat",w,z);   // Saida a gnuplot: w[i] z[i]
\end{lstlisting}}}
\end{frame}

\begin{frame}[fragile]
\frametitle{Funciones}
\begin{itemize}
\item Ejemplo: Suma de todas las componentes \\
{\footnotesize{\begin{lstlisting}{}
double sum (hdnum::Vector<double> x) {
  double s(0.0);
  for (std::size_t i=0; i<x.size(); i=i+1)
    s = s + x[i];
  return s;
}
\end{lstlisting}}}
\item Versión mejorada de la función con \textbf{template} y uso por referencia\\
{\footnotesize{\begin{lstlisting}{}
template<class T>
T sum (const hdnum::Vector<T>& x) {
  T s(0.0);
  for (std::size_t i=0; i<x.size(); i=i+1)
    s = s + x[i];
  return s;
}
\end{lstlisting}}}
\item El uso por referencia es mejor para objetos grandes.
\end{itemize}
\end{frame}

\subsection{Matrices}

\begin{frame}[fragile]
\frametitle{\lstinline{hdnum::DenseMatrix<T>}}
\begin{itemize}
\item \lstinline{hdnum::DenseMatrix<T>} Es una plantilla o Template de clase.
\item Convierte un elemento tipo \lstinline{T} en una matriz.
\item También es posible incluir complejos y su precisión.
\item Las matrices son como las conocemos en matemáticas:
\begin{itemize}
\item Dimensión de $m\times n$ .
\item Inicia en elemento $0$ hasta $m-1$ o, hasta $n-1$ numerados consecutivamente.
\item El conjunto de las matrices $m\times n$ constituyen un espacio vectorial.
\item Multiplicación de vectores y de matrices.
\end{itemize}
\item Los siguientes ejemplos se pueden encontrar en el archivo \lstinline{matrizen.cc}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Construcción y acceso}
\begin{itemize}
\item Construcción con y sin inicialización \\
{\footnotesize{\begin{lstlisting}{}
hdnum::DenseMatrix<float> B(10,10);     // 10x10 Matrix sin inicializar
hdnum::DenseMatrix<float> C(10,10,0.0); // 10x10 Matrix inicializada
\end{lstlisting}}}
\item Acceso a elementos\\
{\footnotesize{\begin{lstlisting}{}
for (int i=0; i<B.rowsize(); ++i)
  for (int j=0; j<B.colsize(); ++j)
    B[i][j] = 0.0;          // Ahora la matriz B está inicializada
\end{lstlisting}}}
\item El objeto matriz se elimina al final del ciclo.
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Copia y asignación}
\begin{itemize}
\item Constructor copia: Crea una matriz como copia de otra
{\footnotesize{\begin{lstlisting}{}
hdnum::DenseMatrix<float> D(B); // D copia de B
\end{lstlisting}}}
\item Asignación y tamaño de las copias
{\footnotesize{\begin{lstlisting}{}
hdnum::DenseMatrix<float> A(B.rowsize(),B.colsize()); //Tamano correcto
A = B;                    // Copia
\end{lstlisting}}}
\item Extractos de matrices (Submatrices)\\
{\footnotesize{\begin{lstlisting}{}
hdnum::DenseMatrix<float> F(A.sub(1,2,3,4));// 3x4  Submatriz (1,2)
\end{lstlisting}}}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Calculando con matrices}
\begin{itemize}
\item Operaciones de espacio vectorial: Ojo, las matrices deben
tener el tamaño correcto!)\\
{\footnotesize{\begin{lstlisting}{}
A += B;           // A = A+B
A -= B;           // A = A-B
A *= 1.23;        // Multiplicación por escalar
A /= 1.23;        // División por escalar
A.update(1.23,B); // A = A + s*B
\end{lstlisting}}}
\item Matrices, Vectores y multiplicación de matrices\\
{\footnotesize{\begin{lstlisting}{}
hdnum::Vector<float> x(10,1.0); // Construimos dos vectores
hdnum::Vector<float> y(10,2.0);
A.mv(y,x);               // y = A*x
A.umv(y,x);              // y = y + A*x
A.umv(y,(float)-1.0,x);  // y = y + s*A*x
C.mm(A,B);               // C = A*B
C.umm(A,B);              // C = C + A*B
A.sc(x,1);               // Hace x la primera columna de A
A.sr(x,1);               // Hace x la primera fila de A
float d=A.norm_infty();  // Halla la norma de la suma de las filas
d=A.norm_1();            // Halla la norma de la suma de las columnas
\end{lstlisting}}}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Funciones de salida auxiliares}
\begin{itemize}
\item Salida de matrices \\
{\footnotesize{\begin{lstlisting}{}
std::cout << A.sub(0,0,3,3) << std::endl;// Impresion
A.iwidth(2);                // Digitos en la salida del indice
A.width(10);                // Numero total de digitos
A.precision(4);             // Posiciones decimales
std::cout << A << std::endl;// Nueva publicacion
\end{lstlisting}}}
\item Algunas funciones auxiliares 
{\footnotesize{\begin{lstlisting}{}
identity(A);
spd(A);
fill(x,(float)1,(float)1);
vandermonde(A,x);
\end{lstlisting}}}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Salida de muestra}
{\footnotesize{\begin{lstlisting}{}
               0           1           2           3
  0   4.0000e+00 -1.0000e+00 -2.5000e-01 -1.1111e-01
  1  -1.0000e+00  4.0000e+00 -1.0000e+00 -2.5000e-01
  2  -2.5000e-01 -1.0000e+00  4.0000e+00 -1.0000e+00
  3  -1.1111e-01 -2.5000e-01 -1.0000e+00  4.0000e+00
\end{lstlisting}}}
\end{frame}

\begin{frame}[fragile]
\frametitle{Funciones con argumentos matriciales}
Ejemplo de una función de una matriz $A$ y de un vector  $b$
inicializados.

{\footnotesize{\begin{lstlisting}{}
template<class T>
void initialize (hdnum::DenseMatrix<T>& A, hdnum::Vector<T>& b)
{
  if (A.rowsize()!=A.colsize() || A.rowsize()==0)
    HDNUM_ERROR("need square and nonempty matrix");
  if (A.rowsize()!=b.size())
    HDNUM_ERROR("b must have same size as A");
  for (int i=0; i<A.rowsize(); ++i)
    {
      b[i] = 1.0;
      for (int j=0; j<A.colsize(); ++j)
        if (j<=i) A[i][j]=1.0; else A[i][j]=0.0;
    }
}
\end{lstlisting}}}
\end{frame}
En la siguiente sección se tratan los solucionadores de sistemas de ecuaciones.
Si el sistema de ecuaciones es lineal, se utiliza el método de descomposición LR 
o QR.  En el caso no lineal, como por ejemplo en el archivo num1, que utiliza 
iteraciones de punto fijo, se utiliza el método de Newton.

\subsection{Método LR}

\subsubsection{Breve explicación del algoritmo}
El método de descomposición LR se utiliza para resolver un sistema
de ecuaciones de la forma $Ax=b$. Se busca descomponer la matriz de coeficientes 
$A$ que es cuadrada en dos matrices, una matriz $L$ matriz triangular inferior y 
otra matriz $R$ matriz triangular superior, de tal forma que el producto sea
$A=LR$. Cuando es necesario realizar intercambio de filas ésto conduce a un 
sistema de la forma $PA = LR$.  Los pivotes aseguran que los elementos de la Diagonal 
no son cero, de lo contrario no se puede usar el algorítmo.

Por un lado, se hace una distinción entre pivotamiento parcial, que asegura que el
elemento más grande de la columna debajo de la diagonal en términos de cantidad se
intercambie en la diagonal mediante permutaciones de fila. Con la rotación total, uno mira la
matriz completa debajo de la diagonal y busca el elemento más grande en términos de
cantidad para cambiarlo a la entrada de la diagonal actual usando operaciones de fila y
columna. El elemento más grande en términos de valor absoluto se elige para reducir los
errores numéricos.

\subsubsection{Como hacer la descomposición LR}
Para hacer un programa que resuelva un sistema $Ax=b$ utilizando la descomposición 
LR, se procede de la siguiente forma:
\begin{itemize}
\item Se crea el vector $b$ y la matriz $A$. veamos el siguiente ejemplo:

  {\footnotesize{\begin{lstlisting}{}
Vector<number> b(3);
b[0]=15;
b[1]=73;
b[2]=12;

DenseMatrix <number> A(3,3);
A[0][0]=2;   A[0][1]=1;   A[0][2]=7;
A[1][0]=8;   A[1][1]=8;   A[1][2]=33;
A[2][0]=-4;  A[2][1]=10;  A[2][2]=4;
\end{lstlisting}}}

\item Además, necesitamos los vectores $x$ y $p$. Si se realiza un pivoteo total, 
se debe crear otro vector $q$. Para mejorar la condición de la matriz, 
las funciones \lstinline{row_equilibrate} y \lstinline{apply_equilibrate} se pueden necesitar
para lo cual se requiere un vector adicional $s$:

  {\footnotesize{\begin{lstlisting}{}
Vector<number> x(3,0.0);
Vector<number> s(3);
Vector<std::size_t> p(3);
Vector<std::size_t> q(3);
\end{lstlisting}}}

\item Como ya se mencionó en el punto anterior, el condicionamiento de la matriz $A$ 
  se puede mejorar desde el principio. Esto se hace usando las funciones \lstinline{row_equilibrate}
  y \lstinline{apply_equilibrate}. La aplicación de los comandos se puede ver en los siguientes ejemplos.

\item Ahora se aplica una de las siguientes funciones a la matriz $A$ y al vector de permutación 
$p$ creado previamente. En nuestro ejemplo realizamos un pivoteo total, por lo que 
necesitamos el vector adicional $q$:
  {\footnotesize{\begin{lstlisting}{}
row_equilibrate (A,s);
lr_fullpivot(A,p,q);
\end{lstlisting}}}
La función \lstinline{lr_partialpivot} se utilizará para el pivoteo parcial 
y la función \lstinline{lr} se utilizará para la descomposición LR sin pivotar.
(El vector de permutación adicional $q$ no es necesario aquí.) Ahora podemos 
usar el sistema de ecuaciones para resolver distintos lados derechos.

\item Para esto necesitamos preparar el lado derecho de la siguiente forma:

{\footnotesize{\begin{lstlisting}{}
apply_equilibrate(s,b);
permute_forward(p,b);
\end{lstlisting}}}

\item Luego llamamos a la función \lstinline{solveL}, que recibe la matriz $A$, 
el vector de la derecha por un vector $y$ como parámetros en los que 
se almacena la solución del sistema de ecuaciones $Ly = b$. 
Para ahorrar espacio de almacenamiento se puede 
escribir el resultado en el vector ya existente $b$.

\item Finalmente, se requiere la función \lstinline{solveR}, que resuelve el 
sistema de ecuaciones $Rx = y$. La función necesita la matriz $A$, el vector de la 
derecha y (del sistema de ecuaciones $Ly = b$) así como el vector $x$, 
en el que se guarda el resultado final:

  {\footnotesize{\begin{lstlisting}{}
solveL(A,b,b);
solveR(A,x,b);
\end{lstlisting}}}

\item Si se ha realizado un pivoteo total, las permutaciones que se almacenaron
 en el vector $q$ (transformaciones de columna de $A$) deben aplicarse al resultado
 $x$ usando \lstinline{permute_backward}:

  {\footnotesize{\begin{lstlisting}{} permute_backward(q,x);
\end{lstlisting}}}

\item La solución del sistema lineal de ecuaciones ahora se almacena en el vector x. 
En nuestro caso:
    {\footnotesize{\begin{lstlisting}{}
x[0] = 1
x[1] = 2
x[2] = 3
\end{lstlisting}}}
  \end{itemize}



\subsection{Explicaciones detalladas del algoritmo \lstinline{lr.hh}}
\begin{itemize}
\item \textbf{La función \lstinline{lr}}: Al principio se comprueba para todas 
las funciones si existe una matriz cuadrada no vacía y si el vector $p$ 
es compatible con la matriz dada. El primer bucle for busca una fila de
la matriz cuyo elemento diagonal no sea igual a cero. A continuación, 
esta línea se compara con la de la corriente Todos los elementos diagonales
intercambiados. Las permutaciones que resultan de la búsqueda pivote 
se almacenan en el vector $p$.

{\footnotesize{\begin{lstlisting}{}
for (std::size_t k=0; k<A.rowsize()-1; ++k)
{
  // finde Pivotelement und vertausche Reihen
  for (std::size_t r=k; r<A.rowsize(); ++r)
    if (A[r][k]!=0)
    {
      p[k] = r;   // speichere Permutation im Schritt k
      if (r>k)    //tausche komplette Reihe falls r!=k
        for (std::size_t j=0; j<A.colsize(); ++j)
        {
          T temp(A[k][j]);
          A[k][j] = A[r][j];
          A[r][j] = temp;
        }
      break;
    }
    if (A[k][k]==0) HDNUM_ERROR("matrix is singular");
    // Moifikation
    for (std::size_t i=k+1; i<A.rowsize(); ++i)
    {
      T qik(A[i][k]/A[k][k]);
      A[i][k] = qik;
        for (std::size_t j=k+1; j<A.colsize(); ++j)
          A[i][j] -= qik * A[k][j];
    }
}
\end{lstlisting}}}

  En el segundo ciclo $for$, se crea la matriz triangular con la matriz A
  permutada.

\item \textbf{La función \lstinline{lr_partialpivot}}: Parametros :
  Matriz $A$ y vector de permutación $p$.  Ésta función realiza un pivoteo parcial.
  Procede de la siguiente manera: Primero, el vector $p$ se inicializa describiéndolo
  con los valores de $0$ a $n-1$ (Donde $A \in \mathbb{R^{\mathrm{n}\times \mathrm{n}}}$).  
  Luego, el elemento pivote (el elemento más grande en términos de magnitud) se busca en la columna actual
  debajo del elemento diagonal en la matriz $A$ y la permutación requjerida para cambiarlo
  a la diagonal que se almacena en el vector $p$:

{\footnotesize{\begin{lstlisting}{}
for (std::size_t k=0; k<A.rowsize()-1; ++k)
{
   // finde Pivotelement
  for (std::size_t r=k+1; r<A.rowsize(); ++r)
    if (abs(A[r][k])>abs(A[k][k]))
    p[k] = r; // speichert Permutation im Schritt k
}
\end{lstlisting}}}
  En el siguiente ciclo, las líneas $k$ y $j$ se intercambian de modo que 
  el elemento pivote se encuentre en la diagonal.

\item  \textbf{La función \lstinline{lr_fullpivot}}: Funciona de manera similar a la función 
  anterior \lstinline{lr_partialpivot}, pero necesita un vector adicional $q$ para poder realizar un pivoteo total. 
  No solo es posible intercambiar filas, sino también intercambiar columnas, 
  que se almacenan en el vector $q$.

\item \textbf{La función \lstinline{permute_forward}}: 
  El vector $p$ ha almacenado las permutaciones necesarias. En esta función, las permutaciones 
  de línea se transfieren al vector:

{\footnotesize{\begin{lstlisting}{}
for (std::size_t k=0; k<b.size()-1; ++k)
  if (p[k]!=k)
  {
     T temp(b[k]);
     b[k] = b[p[k]];
     b[p[k]] = temp;
  }
\end{lstlisting}}}

\item \textbf{La función \lstinline{permute_backward}}: 
  Ésta función se utiliza al final del algorítmo LR para deshacer las permutaciones 
  realizadas en la función \lstinline{permute_forward} para el vector de la derecha.

\item \textbf{La función \lstinline{row_equilibrate}}: 
  Esta función se utiliza antes del algoritmo actual para mejorar la condición de la matriz de 
  (equilibrio). Los valores por los que se dividen las filas de la matriz se almacenan en el vector $s$:

{\footnotesize{\begin{lstlisting}{}
for (std::size_t k=0; k<A.rowsize(); ++k)
{
  s[k] = T(0.0);
    for (std::size_t j=0; j<A.colsize(); ++j)
      s[k] += abs(A[k][j]);
  if (s[k]==0) HDNUM_ERROR("row sum is zero");
    for (std::size_t j=0; j<A.colsize(); ++j)
      A[k][j] /= s[k];
}
\end{lstlisting}}}


\item \textbf{La función \lstinline{apply_equilibrate}}: 
  Los cambios que se hicieron a la matriz $A$ también se aplican aquí al vector $b$ 
  para obtener la solución correcta.

\item \textbf{La función \lstinline{solveL}}: Paramétros : Vector $x$
  y el vector  $b$.  Ésta función resuelve la ecuación $Lx=b$. Aquí $x$ se 
  determina iterativamente de la siguiente forma:
  $x_i= b_i - \sum_{j=0}^{i-1} l_{ij}x_j$

{\footnotesize{\begin{lstlisting}{}
for (std::size_t i=0; i<A.rowsize(); ++i)
{
  T rhs(b[i]);
  for (std::size_t j=0; j<i; j++)
    rhs -= A[i][j] * x[j];
  x[i] = rhs;
}
\end{lstlisting}}}

\item \textbf{La función \lstinline{solveR}}: 
  Ésta función resuelve la ecuación $Rx=b$. 
  Por lo tanto el vector $x$ se determina de la siguiente manera:
  $x_i= b_i - \sum_{j=i+1}^{n-1}r_{ij}x_j$ (aquí está
  $R \in \mathbb{R}^{n \times n}$)

{\footnotesize{\begin{lstlisting}{}
for (int i=A.rowsize()-1; i>=0; --i)
{
  T rhs(b[i]);
  for (std::size_t j=i+1; j<A.colsize(); j++)
    rhs -= A[i][j] * x[j];
  x[i] = rhs/A[i][i];
}
\end{lstlisting}}}

\end{itemize}



\subsection{Método de iteración - archivo \lstinline{newton.hh}}

  Ahora sabemos cómo resolver sistemas lineales de ecuaciones de la forma $Ax = b$. 
  Pero, ¿qué se debe hacer si el sistema de ecuaciones no es lineal, por ejemplo, 
  en el caso simple y unidimensional $x^2 = a$? En la lección aprenderá procedimientos 
  que utilizan iteraciones de punto fijo para acercarse mucho a la solución. 
  El archivo \lstinline{newton.hh} proporciona herramientas útiles para resolver este tipo de ecuaciones 
  y sistemas de ecuaciones.  El más importante es el método de Newton, con el que se pueden resolver ecuaciones 
  no lineales de la forma $F (x) = 0$. Pero primero consideramos la formulación concreta 
  de un problema en una clase.

\subsubsection{La clase  \lstinline{SquareRootProblem}}

  Para poder resolver un sistema no lineal de ecuaciones de la forma $f (x) = 0$, 
  primero debemos crear una clase para nuestro problema. Además de un constructor 
  adecuado e información sobre la dimensión del problema, esto requiere un método 
  que proporcione el valor de la función y otro que proporcione la derivada de la función. 
  Mostramos esto con el ejemplo de la clase SquareRootProblem:

{\footnotesize{\begin{lstlisting}{}
class WurzelProblem
{
   public:
    typedef std::size_t size_type;
    typedef N number_type;
    WurzelProblem (number_type a_);
    std::size_t size () const;
    void F (const Vector<N>& x, Vector<N>& result) const;
    void F_x (const Vector<N>& x, DenseMatrix<N>& result) const;

  private:
    number_type a;
};
\end{lstlisting}}}


\begin{itemize}
\item Typedef:

  {\footnotesize{\begin{lstlisting}{}
typedef std::size_t size_type;
typedef N number_type;
\end{lstlisting}}}

Las definiciones de tipo al principio no son métodos, pero son igualmente importantes. 
No sabemos de antemano qué tipo de datos se utilizará en última instancia. Las definiciones 
de tipo están ahí para que el solucionador pueda reconocer más tarde con qué tipo de 
número está trabajando realmente la clase.


\item Constructor:
  {\footnotesize{\begin{lstlisting}{}
WurzelProblem::WurzelProblem (number_type a_)
: a(a_)
{}
\end{lstlisting}}}

Esto nos da la oportunidad de resolver varios problemas de la forma 
$x^2=a$ pasando la $a$ deseada al constructor.

\item Dimensión:

  {\footnotesize{\begin{lstlisting}{}
std::size_t Wurzelproblem::size () const
{
  return 1;
}
\end{lstlisting}}}

\item Valor de la función: $f(x)=x^2-a$:

  {\footnotesize{\begin{lstlisting}{}
void Wurzelproblem::F (const Vector<N>& x, Vector<N>& result) const
{
  result[0] = x[0]*x[0] - a;
}
\end{lstlisting}}}

Necesitamos esta forma especial porque solo podemos resolver problemas de la forma $f (x) = 0$.


\item Derivación: $f'(x)=2x$:
  {\footnotesize{\begin{lstlisting}{}
void Wurzelprobelem::F_x (const Vector<N>& x,
    DenseMatrix<N>& result) const
{
  result[0][0] = number_type(2.0)*x[0];
}
\end{lstlisting}}}
(La derivada debe calcularse manualmente.)
\end{itemize}

\noindent
Ahora que hemos creado nuestra clase, debemos crear el objeto z.B del problema 
$x^2=5$, crear y resolver esto con el método de Newton.  Para ello,
procedemos de la siguiente manera:

\begin{itemize}
  \item Crear el objeto del problema con \lstinline{WurzelProblem} con el nombre
     "problem", que representa la ecuación $x^2=5$:

  {\footnotesize{\begin{lstlisting}{}
WurzelProblem<Number> problem(5.0);
\end{lstlisting}}}
\end{itemize}

\noindent
Ahora tenemos que crear un objeto de la clase Newton y establecer varios parámetros:

\subsubsection{Clase \lstinline{Newton}}
\begin{itemize}
\item De la siguiente manera, puede crear una instancia de la clase \lstinline{Newton} y establecer todos los parámetros:

    {\footnotesize{\begin{lstlisting}{}
Newton newton;                    // Crea un objeto newton
newton.set_maxit(20);             // Numero maximo de iteraciones 
newton.set_verbosity(2);          // Detalle del gasto
newton.set_reduction(1e-100);     // Factor de reduccion
newton.set_abslimit(1e-100);      // Maximo error en valor absoluto
newton.set_linesearchsteps(3);    // Numero maximo de pasos para la busqueda
\end{lstlisting}}}

\item Finalmente necesitamos un vector $u$, en el que se almacena la solución. 
Éste debe teber el mismo tamaño que nuestro problema:

  {\footnotesize{\begin{lstlisting}{}
Vector<Number> u(problem.size());
\end{lstlisting}}}

\item Aquí establecemos el valor inicial para el método de Newton en $17$ Por supuesto, se puede seleccionar otro valor, pero debe asegurarse de que el valor inicial no esté demasiado lejos de la solución, ya que el método de Newton no es globalmente convergente.
  {\footnotesize{\begin{lstlisting}{}
u[0]=17.0;
\end{lstlisting}}}

\item Ahora podemos aplicar el método lstinline{solve} de la clase de \lstinline{Newton} a nuestro problema:

  {\footnotesize{\begin{lstlisting}{}
newton.solve(problem,u);
\end{lstlisting}}}

\item Como solución a este problema raíz en particular, obtenemos el resultado:\\
  $u= 2.2361e+00$
\end{itemize}

Se pueden resolver estos problemas no solo con el método de Newton, como ya se ha visto, sino también con la ayuda de la clase \lstinline{Banach}.

\subsubsection{Explicaciones detalladas de la clase Newton}
La clase Newton consiste escencialmente de un método \lstinline{solve} que se puede
utilizar para resolver sistemas de ecuaciones no lineales. Además de éste método,
también hay algunos parámetros de procedimiento, como el número máximo de iteraciones,
que se pueden configurar en el constructor.

Para resolver, primero se comprueba si el residuo $r=F(x)$ ya es menor que el error \lstinline{abslimit}. Si es así, el valor inicial ya es suficientemente aceptable y el proceso ha terminado. En otro caso, la dirección de búsqueda se determina utilizando la descomposición $LR$ 
$\bigtriangledown f(x_k)^{-1}f(x_k) = z_k$ definitivamente.  Usando un método de búsqueda de línea
simple y un $\lambda$ apropiado en $x_{k+1}=x_k-\lambda z_k$

{\footnotesize{\begin{lstlisting}{}
for (size_type k=0; k<linesearchsteps; k++)
{
  y = x;
  y.update(-lambda,z);                       // y = x-lambda*z
  model.F(y,r);                              // r = F(y)
  N newR(norm(r));                           // Norma calculada
}
if (newR<(1.0-0.25*lambda)*R)                // Comprobacion de la convergencia
{
  x = y;
  R = newR;
  break;
}
else lambda *= 0.5;                          // Reduccion del factor de amortiguacion
if (R<=reduction*R0)                         // Comprobacion de la convergencia
{
  converged = true;
  return;
}
\end{lstlisting}}}


\subsubsection{La clase \lstinline{Banach}}
\begin{itemize}
\item Soluciona un sistema no lineal de la forma $F(x)=0$ usando el método de iteración del punto fijo $x = x - \sigma*F(x)$
\item La función más importante es la función \lstinline{solve}, que permite obtener la solución real
\item Éste método hace uso del teorema del punto fijo de Banach.
\item Una implementación concreta, utiliza la clase \lstinline{Banach} 
no está incluida en ésta documentación ya que es similar a la clase
  \lstinline{Newton} que está funcionando. Se puede ver un ejemplo en el archivo
  \lstinline{wurzelbanach.cc}. La única diferencia está en el parámetro sigma, que también se debe tener en cuenta con Banach.
\end{itemize}




\subsubsection{Implementación}
{\footnotesize{\begin{lstlisting}{}
class Banach
{
  typedef std::size_t size_type;
  public:
    Banach ()
      : maxit(25), linesearchsteps(10), verbosity(0),
        reduction(1e-14), abslimit(1e-30),  sigma(1.0), converged(false);
    void set_maxit (size_type n);
    void set_sigma (double sigma_);
    void set_linesearchsteps (size_type n);
    void set_verbosity (size_type n);
    void set_abslimit (double l);
    void set_reduction (double l);
    template<class M>
    void solve (const M& model, Vector<typename M::number_type> x) const;
    bool has_converged () const;

  private:
    size_type maxit;
    size_type linesearchsteps;
    size_type verbosity;
    double reduction;
    double abslimit;
    double sigma;
    mutable bool converged;
};
\end{lstlisting}}}

\begin{itemize}
\item Con Typedef ahorra papeleo y es más claro, en cuanto al tamaño.

  {\footnotesize{\begin{lstlisting}{}
typedef std::size_t size_type;
\end{lstlisting}}}

\item En el constructor, los valores se asignan a todos los parámetros privados,...

{\footnotesize{\begin{lstlisting}{}
Banach::Banach ()
  : maxit(25), linesearchsteps(10), verbosity(0),
  reduction(1e-14), abslimit(1e-30),  sigma(1.0), converged(false)
{}
\end{lstlisting}}}

\item ...que luego se pueden cambiar con las siguientes funciones.  El parámetro ''maxit''  asegura que el solucionador que se explica más adelante no quede en un bucle infinito en el caso de que no haya convergencia en la iteración del punto fijo, en cuyo caso aborta e informa que no hay convergencia.

 {\footnotesize{\begin{lstlisting}{}
void Banach::set_maxit (size_type n)
{
  maxit = n;
}
\end{lstlisting}}}

\item Aquí se ajusta el parametro $\sigma$.

  {\footnotesize{\begin{lstlisting}{}
void Banach::set_sigma (double sigma_)
{
  sigma = sigma_;
}
\end{lstlisting}}}

\item Cuántos pasos debe tomar el solucionador, antes de abortar?, se puede configurar aquí.

{\footnotesize{\begin{lstlisting}{}
void Banach::set_linesearchsteps (size_type n)
{
  linesearchsteps = n;
}
\end{lstlisting}}}

\item Control de salida: cuanto mayor sea el número establecido, más información se precisa sobre la convergencia en la consola. Lo que significan los números individuales, sin embargo, debe verse en el código fuente si es necesario.

  {\footnotesize{\begin{lstlisting}{}
void Banach::set_verbosity (size_type n)
{
  verbosity = n;
}
\end{lstlisting}}}

\item Tolerancia a fallos
  {\footnotesize{\begin{lstlisting}{}
void Banach::set_abslimit (double l)
{
  abslimit = l;
}
\end{lstlisting}}}

\item Factor de Reducción 
  {\footnotesize{\begin{lstlisting}{}
void Banach::set_reduction (double l)
{
  reduction = l;
}
\end{lstlisting}}}

\item Con el método \lstinline{solve} se puede resolver un modelo dado recurriendo a los miembros privados''.

  {\footnotesize{\begin{lstlisting}{}
template<class M>
void Banach::solve (const M& model, Vector<typename M::number_type> x) const
{
  typedef typename M::number_type N;
  Vector<N> r(model.size());              // Residuo
  Vector<N> y(model.size());              // Soluciones temporales

  model.F(x,r);          // Calculo del residuo no lineal
  N R0(norm(r));         // Norma del resiudal inicial
  N R(R0);               // Norma de la corriente resiudal

  converged = false;

  // Maximo de iteraciones especificadas en la matriz 
  for (size_type i=1; i<=maxit; i++)
  {
    if (R<=abslimit)     //Verifica el valor absoluto del residuo
    {
      converged = true;
      return;
    }
  \end{lstlisting}}}

En caso de que el resultado preliminar no fuera lo suficientemente preciso $(\leqslant
abslimit)$, pasa a la siguiente iteración real y luego se usa un estándar para probar si
el resultado es ahora lo suficientemente preciso y luego se regresa al comienzo del ciclo 
for.  Si el resultado es lo suficientemente preciso, la función ha cumplido su propósito y termina.
{\footnotesize{\begin{lstlisting}{}
  // next iterate
  y = x;
  y.update(-sigma,r);             // y = x-sigma*z
  model.F(y,r);                   // r = F(y)
  N newR(norm(r));                // Calcular la norma

  x = y;                          // Adopción de las nuevas iteraciones 
  R = newR;                       // Almacenamiento estandar

  // Chequea la convergencia
  if (R<=reduction*R0 || R<=abslimit)
  {
    converged = true;
    return;
  }
}
\end{lstlisting}}}

\item El valoor booleano se establece como falso por defecto en principio.  Resuelve la función 
 \lstinline{solve} Si el sistema de ecuaciones tiene éxito, establece el valor en verdadero y este valor se retiene como un miembro privado de la clase. Esta función le dice si el método de punto fijo ya ha tenido éxito y, por lo tanto, también lo volverá a tener éxito.

{\footnotesize{\begin{lstlisting}{}
bool Banach::has_converged () const
{
  return converged;
}
\end{lstlisting}}}
\end{itemize}



\section{Ecuaciones diferenciales ordinarias}

El siguiente capítulo trata sobre el tema central de la conferencia.
Numéricos 1, resolviendo ecuaciones diferenciales ordinarias. Repetir: se trata de una ecuación en la que se da una función así como las derivadas de la función y se intenta averiguar qué función cumple la ecuación. HDNUM proporciona algunas herramientas útiles para resolver este tipo de ecuaciones diferenciales. Muestra cómo preparar una ecuación diferencial para que pueda ser resuelta por un solucionador (cómo el funcionamiento individual se deja a la lección y sus demostraciones) y al mismo tiempo contiene varios de estos solucionadores. El hecho es que tanto las ecuaciones diferenciales como los solucionadores están empaquetados en clases. Estas clases deben tener ciertos métodos para ser compatibles entre sí. Comencemos con un ejemplo de ecuación diferencial:

\subsection{Un buen ejemplo de DGL in HDNUM - \lstinline{modelproblem.hh}}

\begin{itemize}
\item Este archivo sólo contiene la clase
  \lstinline{ModelProblem}, que contiene exactamente los métodos necesarios para la compatibilidad con todos los solucionadores de HDNUM. ¡Así que cada clase de ecuación diferencial debe tener exactamente estas declaraciones de método!
\item La información completa sobre una ecuación diferencial está contenida en la implementación de los métodos.
\item El archivo está escrito para que los objetos de la clase
  \lstinline{ModelProblem} Los problemas modelo en el sentido de la lección son, pero pueden reescribirse para cualquier ecuación diferencial. Cabe señalar que todos los jefes de función de los métodos no se modifican. Esta es la única forma de mantener el nuevo DGL compatible con nuestros solucionadores.
\item Un objeto de la clase de Modelproblem corresponde entonces a una ecuación diferencial a resolver.
\item Si el archivo está incluido en el encabezado, los objetos de la clase de problema del modelo se pueden crear en el programa y luego resolver con el conocimiento de las siguientes secciones.
\end{itemize}

{\footnotesize{\begin{lstlisting}{}
template<class T, class N=T>
class ModelProblem
{
  public:
    typedef std::size_t size_type;
    typedef T time_type;
    typedef N number_type;

    ModelProblem (const N& lambda_)
      : lambda(lambda_);

    std::size_t size () const;
    void initialize (T& t0, hdnum::Vector<N>& x0) const;  //Valores iniciales
    void f (const T& t, const hdnum::Vector<N>& x,        //Función f
      hdnum::Vector<N>& result) const;
    void f_x (const T& t, const hdnum::Vector<N>& x,  //Matriz Jacobiana de f
       hdnum::DenseMatrix<N>& result) const;

  private:
    N lambda;
};
\end{lstlisting}}}


\begin{itemize}
\item Las definiciones de tipo al principio no son métodos, pero merecen una breve explicación. Puede ver a partir de esto que es una clase de plantilla y nunca está claro desde el principio qué tipo de datos se está utilizando realmente. Las definiciones de tipo están ahí para que el solucionador pueda reconocer más tarde con qué tipo de número está trabajando realmente la clase de modelo. Los usamos para poder trabajar con tipos de datos muy precisos (precisión múltiple).

\item El constructor inicializa los parámetros privados si es necesario. Pero no siempre tiene que haber tal cosa.

  {\footnotesize{\begin{lstlisting}{}
template <class T, class N=T>
ModelProblem::ModelProblem (const N& lambda_)
  : lambda(lambda_)
{}
\end{lstlisting}}}

\item Con esta función se determina qué dimensión tiene la ecuación diferencial a resolver.

{\footnotesize{\begin{lstlisting}{}
template <class T, class N=T>
std::size_t ModelProblem::size () const
{
  return 1;
}
\end{lstlisting}}}

\item Los valores iniciales se establecen aquí. $t_0$ es el valor inicial en el tiempo, mientras que $x_0$ es el vector de los valores iniciales. Entonces, en el unidimensional, contiene solo una entrada.

{\footnotesize{\begin{lstlisting}{}
template <class T, class N=T>
void ModelProblem::initialize (T& t0, hdnum::Vector<N>& x0) const
{
  t0 = 0;
  x0[0] = 1.0;
}
\end{lstlisting}}}

\item La función $f$ contiene la ecuación diferencial real.  El vector
 \lstinline{result},
  entonces la solución de la función \lstinline{f} en el momento.
  \lstinline{t} calculado.

{\footnotesize{\begin{lstlisting}{}
template <class T, class N=T>
void ModelProblem::f (const T& t, const hdnum::Vector<N>& x,
  hdnum::Vector<N>& result) const
{
  result[0] = lambda*x[0];
}
\end{lstlisting}}}

\item Esta función representa la matriz jacobiana de la función
  \lstinline{f} en \lstinline{result} a disposición. Esto es requerido por solucionadores implícitos.

{\footnotesize{\begin{lstlisting}{}
template <class T, class N=T>
void ModelProblem::f_x (const T& t, const hdnum::Vector<N>& x,
  hdnum::DenseMatrix<N>& result) const
{
  result[0] = lambda;
}
\end{lstlisting}}}

\item Cualquier parámetro que pueda ser necesario se encuentra en la parte privada de la clase.

\end{itemize}


\subsection{Ejemplo de aplicación \lstinline{modelproblem.hh}}
El archivo \lstinline{modelproblem_high_dim.hh} es una reformulación
del archivo \lstinline{modelproblem.hh} y pone la
ecuación diferenial $u'(t) = \begin{pmatrix}
  5 & -2\\
  -2 & 5
\end{pmatrix}*u(t)$ con valor inicial
$ u(t) = \left( \begin{array}{c}1 \\\ 3 \end{array}\right)$ allí. Esto lo convierte en un ejemplo de la representación de un Ecuación diferencial.

\subsection{El solucionador resuelve DGL - \lstinline{modelproblem.cc}}
\begin{itemize}
\item Este archivo es un excelente ejemplo de resolución de problemas
   Ecuaciones diferenciales.
\item Muestra cómo combinar la clase de ecuación diferencial y la clase de solucionador de tal manera que la ecuación diferencial se resuelve y el resultado se escribe en un archivo de tal manera que se puede trazar.
\end{itemize}

{\footnotesize{\begin{lstlisting}{}
#include <iostream>
#include <vector>
#include "hdnum.hh"
#include "modelproblem.hh"
#include "expliciteuler.hh"
\end{lstlisting}}}

Además de las bibliotecas, el encabezado también incluye el problema del modelo y un archivo para resolver la ecuación diferencial. En este caso, la ecuación diferencial debe resolverse con el Euler explícito.

{\footnotesize{\begin{lstlisting}{}
int main ()
{
  typedef double Number;                // Define el tipo de numero
  typedef ModelProblem<Number> Model;   // Define el tipo de modelo
  Model model(-1.0);                    // Objeto de la clase con lambda =-1
  typedef ExplicitEuler<Model> Solver;  // Elige el solucionador
  Solver solver(model);                 // Inicializar el solucionar con el modelo
  solver.set_dt(0.02);                  // Establecer intervalos de tiempo
  hdnum::Vector<Number> times;          // Vector para intervalos de tiempo
  hdnum::Vector<hdnum::Vector<Number>> states; // Vector solución
  times.push_back(solver.get_time());   // Guarda la hora de inicio
  states.push_back(solver.get_state()); // Fuarda el valor inicial en el vector
  while (solver.get_time()<5.0-1e-6)    // Bucle para aflojar
    {
      solver.step();
      times.push_back(solver.get_time());    // Ahorrar tiempo
      states.push_back(solver.get_state());  // Ahorra el valor
    }

  gnuplot("mp2-ee-0.02.dat",times,states);   // La salida esta en la seccion
                                             // explicado sobre Gnuplot 
  return 0;
}
\end{lstlisting}}}

Un ejemplo alternativo es el archivo 
\lstinline{modelproblem_high_dim.cc}. Pasado por Solver EE otros solucionadores \lstinline{ode.hh} (Ver explicación a continuación) reemplazado,
se puede resolver el DGL con diferentes medios y ver un ejemplo de que un DGL con todos nuestros solucionadores es compatible. 

\subsection{Que debe poder hacer un solucionador? - \lstinline{expliciteuler.hh}}
\begin{itemize}
\item Este archivo contiene la clase \lstinline{ExplicitEuler}.
\item La clase contiene todos los métodos que necesita un solucionador en nuestro contexto.
\item Todos los solucionadores tienen al menos los métodos que 
  \lstinline{ExplicitEuler} tiene, tal vez algunos más.
\item Con la ayuda de este archivo puede resolver todas las ecuaciones diferenciales que tienen la representación mencionada anteriormente en una clase.
\end{itemize}

{\footnotesize{\begin{lstlisting}{}
template<class M>
class ExplicitEuler
{
  public:
    typedef typename M::size_type size_type;
    typedef typename M::time_type time_type;
    typedef typename M::number_type number_type;

    ExplicitEuler (const M& model_)
      : model(model_), u(model.size()), f(model.size());
    void set_dt (time_type dt_);
    void step ();
    const hdnum::Vector<number_type>& get_state () const;
    time_type get_time () const;
    time_type get_dt () const;

  private:  //Die private Member sind bei jedem Solver ähnlich.
    const M& model;      //Referenz auf das Model ist IMMER vorhanden
    time_type t, dt;     //Zeitlichen Variablen
    hdnum::Vector<number_type> u;  //Vektor zur Speicherung von Zeitschritten
    hdnum::Vector<number_type> f;  //mindestens einem Vektor
                  // zur Speicherung von Loesungen
};
\end{lstlisting}}}

\begin{itemize}
\item Primero, un breve comentario sobre las definiciones de tipo al principio: Inicialmente, el solucionador solo obtuvo una referencia a un modelo en el constructor. Sin embargo, todavía no está claro qué tipos de números se utilizan en el modelo y si se pueden llamar a sus funciones. Los typedefs se utilizan para determinar esto. Por lo tanto, el solucionador puede resolver DGL para cualquier tipo de número y solo cuando se compila se determina cuál se refiere realmente.

\item El constructor almacena una referencia al modelo que se supone que debe resolver. Además, aquí se especifican los parámetros para el algoritmo de solución, como el tamaño de los pasos de tiempo, los valores iniciales o similares.
{\footnotesize{\begin{lstlisting}{}
template<class M>
ExplicitEuler::ExplicitEuler (const M& model_)
  : model(model_), u(model.size()), f(model.size())
{
  model.initialize(t,u);
  dt = 0.1;
}
\end{lstlisting}}}

\item Dado que Solver calcula la solución (tiempo) paso a (tiempo) paso, puede determinar qué tan grandes deben ser estos pasos. Cuanto mayores sean los pasos, menos preciso será el resultado, pero menor será el esfuerzo computacional.

{\footnotesize{\begin{lstlisting}{}
template<class M>
void ExplicitEuler::set_dt (time_type dt_)
{
  dt = dt_;
}
\end{lstlisting}}}

\item El algoritmo de solución real está en la función de paso. Decide cómo pasar de un paso al siguiente. Así que aquí está el algoritmo del Euler explícito.

{\footnotesize{\begin{lstlisting}{}
template<class M>
void ExplicitEuler::step ()
{
  model.f(t,u,f);   // berechnet Wert von f an der Stelle t
  u.update(dt,f);   // naechster Funktionswert ist alter Wert+dt*f(t)
  t += dt;          // die Zeit wird um dt nach vorne gesetzt
}
\end{lstlisting}}}

\item El vector solución calculado hasta ahora:
{\footnotesize{\begin{lstlisting}{}
template<class M>
const hdnum::Vector<number_type>& ExplicitEuler::get_state () const
{
  return u;
}
\end{lstlisting}}}
\item El tiempo que se acaba de calcular:
{\footnotesize{\begin{lstlisting}{}
template<class M>
time_type ExplicitEuler::get_time () const
{
  return t;
}
\end{lstlisting}}}

\item Actualiza dt (tamaño del paso):
{\footnotesize{\begin{lstlisting}{}
template<class M>
time_type ExplicitEuler::get_dt () const
{
  return dt;
}
\end{lstlisting}}}
\end{itemize}

\subsection{Insertar Gnuplot en \lstinline{ode.hh}}
Por supuesto, un solucionador numérico no puede proporcionarnos una solución analítica de una ecuación diferencial en forma de función concreta. Pero puede decirnos cómo se ve la función de solución en muchos puntos. Para que podamos hacer algo con estas muchas tuplas numéricas, las visualizamos con Gnuplot. Las siguientes funciones de plantilla nos facilitan esto y escriben el resultado en el formato correcto en un archivo para que luego podamos trazarlo directamente.

\begin{enumerate}
\item
{\footnotesize{\begin{lstlisting}{}
void gnuplot (const std::string& fname, const std::vector<T> t,
 const std::vector<Vector<N> > u)
\end{lstlisting}}}

¡Solo apto para DGL unidimensional! La función recibe un nombre de archivo (.dat) entre comillas, así como la hora y el vector de solución. La función asegura que los datos estén en una especie de tabla en un archivo con el nombre deseado. A continuación, este archivo se puede trazar.
\item
{\footnotesize{\begin{lstlisting}{}
void gnuplot (const std::string& fname, const std::vector<T> t,
 const std::vector<Vector<N> > u, const std::vector<T> dt)
\end{lstlisting}}}

¡Adecuado para DGL bidimensional! Pasas los mismos datos a la función que arriba más el segundo vector de solución. El resultado también es análogo. Sin embargo, al trazar, debe tener en cuenta las peculiaridades de la multidimensionalidad.
\end{enumerate}

Como plantilla de ejemplo, el código de la sección anterior se puede ver al final.

Los comandos de Gnuplot más importantes en la terminal:
\begin{enumerate}
\item \lstinline{gnuplot} - abre Gnuplot
\item \lstinline{plot 'dateiname.dat' using 1:2} - grafica en dos dimensiones usando las columnas 1 vs 2 
\item \lstinline{plot 'dateiname.dat' using 1:2, 'dateiname.dat' using 1:3} - traza gráficas 1 vs 2, y 1 vs 3.
\item \lstinline{splot 'dateiname.dat' using 1:2:3} - Grafica en tres dimensiones
\item \lstinline{exit} - termina Gnuplot
\end{enumerate}


\subsection{Proceso de un paso- \lstinline{ode.hh}}

Ahora que hemos visto cómo se empaquetan exactamente una ecuación diferencial y un solucionador en una clase
para que sean compatibles entre sí y cómo luego se resuelve la ecuación diferencial con el solucionador, podemos pasar a ver varios de estos solucionadores. En la conferencia conocerás los métodos implícitos y explícitos de Runge-Kutta como los ejemplos más importantes. El Euler explícito, que teníamos antes como ejemplo, también es parte de él. En el archivo \lstinline{ode.hh}
se implementan varios de estos solucionadores. Para que pueda resolver cualquier ecuación diferencial (nuevamente empaquetada en una clase, por supuesto) con cada solucionador, todas estas clases de solucionador tienen métodos con los mismos cabezales de función. Solo en la forma en que se implementan estas funciones difieren, lo que luego define el procedimiento individual. Además de los métodos de la clase discutidos anteriormente \lstinline{ExplicitEuler} tener las clases en
\lstinline{ode.hh} algunas funciones adicionales. Los métodos con control de tamaño de paso también se modifican ligeramente.


\subsubsection{Los procedimientos en ode.hh}
\begin{itemize}
\item Método explícito de Runge-Kutta 
  \begin{itemize}
  \item\lstinline{EE} - Método explícito de Euler
  \item\lstinline{ModifiedEuler}
  \item\lstinline{Heun2}
  \item\lstinline{Heun3}
  \item\lstinline{Kutta3}
  \item\lstinline{RungeKutta4}
  \end{itemize}
\item Método implícito de Runge-Kutta 
  \begin{itemize}
  \item \lstinline{IE} - Método implícito de Euler
  \item \lstinline{DIRK} -Procedimiento implícito diagonal
  \end{itemize}
\item Control de tamaño del paso
  \begin{itemize}
  \item\lstinline{RKF45}
  \item\lstinline{RE} - Extrapolación de Richardson
  \end{itemize}
\end{itemize}

\subsection{Das allgemeine Runge-Kutta-Verfahren - \lstinline{RungeKutta}}
Diese Klasse ist dazu gebaut, um eine Differentialgleichung mit einem
beliebigen expliziten oder impliziten Runge-Kutta-Verfahren zu
Lösen. Die Differentialgleichung muss dabei auf die gleiche Weise wie
bisher in einer Klasse implementiert sein.

\subsubsection{Bedienung der Klasse \lstinline{RungeKutta}}
Der einzige Unterschied zur Handhabung einer anderen Solverklasse
besteht darin, dass dem Konstruktor zusätzlich noch das
Butcher-Tableau des gewünschten Verfahrens übergeben werden muss. Der
Funktionskopf im Namespace hdnum sieht folgendermaßen aus:
{\footnotesize{\begin{lstlisting}{} RungeKutta::RungeKutta (const
      M& model, DenseMatrix<number_type> A_, Vector<number_type> b_,
      Vector<number_type> c_)
\end{lstlisting}}}

Die Matrix \lstinline{A_} und die Vektoren \lstinline{b_} und
\lstinline{c_} kommen direkt aus dem Butcher Tableau. Alles Weitere
ist dann analog zu den anderen Solverklassen. N ist ein
Templateparameter der Klasse. Möchte man statt dem Newtonverfahren das
Banachverfahren zur Lösung von nichtlinearen Gleichungssystemen
verwenden, so ist Banach ein zweiter Templateparameter den man beim
Erzeugen eines Objektes davor schreibt. In diesem Fall macht es auch
Sinn dem Konstruktor als weiteres Argument am Schluss noch einen
$number\_type \ sigma\_$ zu übergeben. Der entsprechende Konstruktor
ist implementiert.  Das könnte dann folgendermaßen aussehen:
{\footnotesize{\begin{lstlisting}{} RungeKutta<Model, Banach>
      Solver(model, A, b, c, 0.5)
\end{lstlisting}}}

Dabei müsste dann model ein Modelproblem vom Typ Model sein und $A$ eine
$n \times n$ Matrix, sowie $b$ und $c$ $n$-dimensionale Vektoren. Das
Sigma im Banachverfahren wäre in diesem Fall dann 0,5.


\paragraph{Die Algorithmen hinter Funktion \lstinline{void step}}
\begin{itemize}
\item Die Funktion \lstinline{step} unterscheidet von Anfang an, ob es
  sich um ein explizites oder implizites Verfahren handelt. (Die
  Testfunktion erkennt dies am Butchertableau).
\item Im expliziten Fall sind alle Werte bekannt und in privaten
  Variablen gespeichert, um
  $u_{n}^h = u_{n-1}^h +h_n(b_1k_1+...+b_sk_s)$ mittels
  $k_1 = f(t_{n-1},u_{n-1}^h)$,
  $k_i = f(t_{n-1}+c_ih_n, u_{n-1}^h+h_n \sum_{j=1}^{i-1}a_{ij}k_j)$
  zu berechnen. Dabei wird die Funktion $f$ von der Problemklasse
  bereitgestellt

\item Im impliziten Fall gilt es $k_i = f(t_{n-1}+c_ih_n,
  u_{n-i}^h+h_n \sum_{j=1}^s a_{ij}k_j)$ für $i = 1,...,s$ zu lösen
  und damit $u_n^h = u_{n-1}^h + h_n \sum_{i = 1}^s b_ik_i $ zu
  bestimmen. Numerisch ist es jedoch einfacher, zunächst $z_i := h_n
  \sum_{j=1}^s a_{ij}k_j$ für $i = 1,...,s$ zu berechnen und dann die
  $k_i$ über $K= h_n^{-1}A^{-1}Z$ zu bestimmen. Dabei sind $K$ und $Z$
  Vektoren aus Vektoren.

  Falls $b^T$ gleich der letzten Zeile von $A$ ist, kann man sich die
  Berechnung der $k_i$ sparen und direkt $u_n^h = u_{n-1}+z_s$
  berechnen. Die nichtlinearen Gleichungssysteme bei der Berechnung
  der $z_i$ werden wahlweise mit dem Banach- oder Newtonverfahren
  gelöst, für die eine Problemklasse erstellt wird.

\item Sowohl für das Banach- als auch für das Newtonverfahren benötigt
  man eine bestimmte Problemklasse, die das zu lösende Problem
  modelliert. In unserem Fall erfüllt diesen Zweck die Klasse
  \lstinline{ImplicitRungeKuttaStepProblem}. Diese wird im Konstruktor
  mit allen wichtigen Größen der Klasse \lstinline{RungeKutta}
  initialisiert. Wichtig zu wissen ist jedoch, dass Banach- und
  Newtonverfahren keine Nullstellen von Funktionen, die Vektoren von
  Vektoren als Argument haben, berechnen können. Deshalb muss man $Z$
  als einen Vektor der Größe $n*s$ auffassen und erst danach wieder
  auf $s$ Vektoren der Größe $n$ zurückrechnen.

\item Das Herzstück der Klasse
  \lstinline{ImplicitRungeKuttaStepProblem} sind die Funktionen
  \lstinline{void F} und \lstinline{void F_x}. In der ersten wird die
  Funktion modelliert, die annuliert wird, wenn die richtigen $z_i$
  getroffen sind, während die zweite Funktion nur im Newtonverfahren
  benötigt wird und die Jacobimatrix der ersten Funktion bereitstellt.

\item Die Funktion \lstinline{F} sieht dabei folgendermaßen aus:
  \begin{align*}
    F: \mathbb{R}^{n*s} \to \mathbb{R}^{n*s}, \left( \begin{array}{c}z_1 \\...\\...\\z_s\end{array} \right) \mapsto \left( \begin{array}{c}F_1(z_1,...,z_s)\\...\\...\\F_s(z_1,...,z_s)\end{array} \right)
  \end{align*}
  wobei $F_i(z_1,...,z_s) = z_i-h_n \sum_{j=1}^s
  a_{ij}f(t_{n-1}+c_jh_n, u_{n-1}+z_j)$ für $i = 1,...,s$.

\item Die zu berechnende Jacobimatrix ist eine Blockmatrix aus
  $s\times s$ Blöcken der Größe $n \times n$. Dabei gilt für den
  $(i,j)$-ten Block:
  \begin{align}
    J_{ij} &= \frac{\partial F_i}{\partial z_j}(z_1,...,z_s) = \frac{\partial}{\partial z_j}(z_i - h_n \sum_{k=1}^s a_{ik}f(t_{n-1}+c_kh_n, u_{n-1}+z_k)) \\
           &= \delta_{ij}I-h_n \sum_{k=1}^s a_{ik} \frac{\partial}{\partial z_j}f(t_{n-1}+c_kh_n, u_{n-1}+z_k)\\
           &= \delta_{ij}I-h_n a_{ij} \frac{\partial f}{\partial z_j}(t_{n-1}+c_jh_n, u_{n-1}+z_j)
  \end{align}
  $ \frac{\partial f}{\partial z_j}$ erhalten wir dabei aus der
  Funktion \lstinline{f_x} der Differentialgleichungsklasse.
\end{itemize}

\subsubsection{Konsistenzordnungstests mit \lstinline{void ordertest}}

Mit dieser Funktion kann man die Konsistenzordnung eines allgemeinen
Runge-Kutta-Verfahrens, dessen Butchertableau man kennt,
bestimmen. Dazu ist es jedoch nötig, in der Klasse der
Differentialgleichung die exakte Lösung in der eine Funktion u
anzugeben.  Ein Beispiel dazu findet man in der Datei
\lstinline{modelproblem.hh}.  Der Funktionskopf von
\lstinline{ordertest} sieht folgendermaßen aus:
{\footnotesize{\begin{lstlisting}{} typedef double Number;
      template<class M, class S> void ordertest(const M&
      model, S solver, Number T, Number h_0, int L)
    \end{lstlisting}}}

Dabei beschreibt \lstinline{model} eine gewöhnliche
Differentialgleichung, \lstinline{solver} ist ein Löser und T der
Zeitpunkt, der für den Konsistenzordnungstest verwendet werdern
soll. $h_0$ ist die initiale Schrittweite und L die Anzahl, wie oft
$h_0$ bei der Berechnung halbiert werden soll.  Auf der Konsole wird
dann in der i-ten Zeile der Fehler im i-ten Schritt, sowie die damit
berechnete Konsistenzordnung ausgegeben.  Ein kurzes
Anwendungsbeispiel gibt es in der Datei
\lstinline{model_ordertest.cc}.

\paragraph{Berechnung der Konsistenzordnung}
\begin{itemize}
\item Für die Konsistenzordnung $\alpha$ gilt: $||u-u_h||=Ch^\alpha$
\item
  $E_{n_1,n_2}= \frac{||u(T)-u_{h_1}(T)||}{||u(T)-u_{h_2}(T)||} =
  \frac{Ch_1^\alpha}{Ch_2^\alpha}=
  \left(\frac{h_1}{h_2}\right)^\alpha$, wobei $h_i=\frac{h_0}{2^i}$
  gewählt wird.
\item
  $\alpha= \frac{log E_{n_1,n_2}}{log \left( \frac{h_1}{h_2} \right)}$
\item Im Fall, dass T nicht direkt von einem Zeitschritt getroffen
  wird, also $u_{h_i}(T)$ nicht direkt berechnet wird, muss man den
  Berechnungsalgorithmus anpassen. Dabei unterscheidet man mehrere
  Fälle. Wird T fast getroffen (Abstand kleiner als vorgegebenes
  $\epsilon$), so nimmt man diesen Wert, das heißt man vergrößert den
  letzten Schritt um maximal $\epsilon$, sodass man T genau
  trifft. Andernfalls verändert man die Schrittweite der letzten ein
  oder zwei Schritte um T genau zu treffen.
\end{itemize}



\subsection{Anwendungsbeispiele}
Im Ordner \lstinline{examples/num1} sind einige interessante Anwendungsbeispiele gegeben, bei denen man sehen kann, wie die Verfahren aus der Vorlesung in anderen Naturwissenschaften verwendet werden.

\subsubsection{Hodgkin-Huxley-Modell}
Das Hodgkin-Huxley-Modell kommt aus der Neurobiologie und beschreibt die Vorgänge an der Zellmembran einer Nevenzelle bei der Reizweiterleitung. Für genauere Erklärungen siehe \url{https://de.wikipedia.org/wiki/Hodgkin-Huxley-Modell}.

\subsubsection{n-body Problem}
Das n-body Problem ist ein Problem der Astrophysik, bei dem es um die Bewegungen von Himmelskörpern geht. Für genauere Erklärungen siehe \url{https://en.wikipedia.org/wiki/N-body_problem}.

\subsection{Van der Pol Oszillator}
Dabei handelt es sich um ein Schwingungsbeispiel, dass in unserem Fall ein gutes Beispiel für eine steife Differentialgleichung ist. Genaueres dazu gibt es unter \url{https://de.wikipedia.org/wiki/Van-der-Pol-System} bei Wikipedia.




\begin{appendices}

\section{Kleiner Programmierkurs}

\section{Unix Kommandos}
In der folgenden Tabelle sind die wichtigsten Kommandos fürs Terminal (das schwarze Fenster) zusammengestellt. Alle Worte in Großbuchstaben sind Platzhalter.


\begin{tabular}{|c|c|}\hline
   Kommando & Auswirkungen \\ \hline
   cd & gehe ins home-Verzeichnis \\ \hline
   cd ORDNERNAME & gehe in einen Ordner, dieser muss im Ordner enthalten sein, \\ & in dem man sich gerade befindet \\ \hline
   cd .. & gehe einen Ordner höher \\ \hline
   ls & zeigt an, was sich in dem Ordner befindet, \\
   & in dem man gerade ist \\ \hline
   tar cvf GEWÜNSCHTERNAME.tar & \\  Inhalt1.cc Inhalt2.cc ... Inhaltn.cc & erstellt ein Tar-Archiv \\ \hline
   tar xvf TARNAME.tar  & entpackt das Tar \\ \hline
   g++ -std=c++11 -o DATEINAME & \\  DATEINAME.cc & kompilieren (-std=c++11 braucht nicht jeder) \\ \hline
   ./DATEI & Ausführen der Datei \\ \hline


 \end{tabular}

\end{appendices}

\bibliographystyle{plain}
\bibliography{hdnum.bib}

\end{document}
